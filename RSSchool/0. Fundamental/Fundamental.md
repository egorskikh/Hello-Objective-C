# Fundamental

## Расширение имен файлов

| Расширение  | Описание | Что тут? |
| ------------- | ------------- | ------------- | 
| .h | Файл заголовка (Header)  | @interface Также можно определять протоколы, константы, перечисления, прототипы функции |
| .m  | Исходный файл Objective-C | @implementation Файлы реализации. В них определяется реализация интерфейса определенного в заголовочном файле. Это реализация в дальнейшем не видна тому классу который использует интерфейс из заголовочного файла.  |
| .c  | Исходный файл на языке C  |  |
| .cc / .cpp  | Исходный файл на языке C++  |  |
| .mm  | Исходный файл Objective-C++  |  |
| .pl  | Исходный файл Perl  |  |
| .o  | Объектный (компилированный) файл |  |

## Data Type
### Базовые  типы || Basic

| int  | float  | double | char | ... |
| ------------- | ------------- | ------------- | ------------- | ------------- | 

### Производные  типы || Derived

| struct  | union | pointer | array | function | ... |
| ------------- | ------------- | ------------- |  ------------- | ------------- | ------------- | 

## Scope (Область видимости)
>Это область программы с определенных в ней переменными. 
На базовом уровне есть:
* global
* local

Пример Scope в коде:
```objc
{
  // - Это область видимости
}
```

## Function
>Функция - это набор выражений которые собраны в исполняемую последовательность. 

```objc
char foo(int bar)
{
    rerurn bar + "0";
}
```
Разбор: 
| char  | foo | (int bar) |  
| ------------- | ------------- | ------------- | 
| возвращаемый тип | имя функции  | принимаемые параметры  | 

```objc
{                    // 
  rerurn bar + "0"; // тело функции
}                  //
```
Тело функции должно завершаться ключевым словом *return* если нет возвращаемого типа *(void)*.

## Memory Areas

Память необходима для того что бы хранить в ней данные, с которыми работает программа в процессе своего выполнения.
Память делиться на три типа:
* Global
* Stack
* Heap (куча)

### Global 
| Global  | 
| ------------- | 
| Глобальная память выделяется системой при запуске программы. И очищается ей при завершении этой программы. Глобальная память является памятью глобального scope(а). Переменные созданные в глобальной памяти имеют постоянный адрес.  | 



```objc
#include <stdio.h>

int a = 123;              // - global variable

void foo() {
    printf("%d", a);
}
```

### Stack 

| Stack  | 
| ------------- | 
| Стек - это память локальной области видимости. И с малым объёмом. Отличительной особенностью стека, является то что переменные созданные в стеке удаляются из него при выходе из области видимости этого стека. | 


```objc
int main(int argc, const char * argv[]) {

    if (1 != 2)
    {
        int a = 0;             // - stack variable
        printf("%d", a);
    }
    
    return 0;
}
```

### Heap 
| Heap  | 
| ------------- | 
| Куча - это память большого объема. Объекты созданные в куче не ограничены в области видимости. Если есть ссылка на объект из кучи, тогда доступ к этому объекту может быть предоставлен из любого места программы. Объекты в куче - не очищаются автоматический.  | 



*Ответственность за очистку памяти этих объектов лежит на том кто их создал.*
```objc
int main(int argc, const char * argv[]) {
    
    int *ptr = malloc(sizeof(int));        // переменная ptr содержит адрес области памяти выделенной в куче с помощью функции malloc 
    *ptr = 123;                            // с ней можно работать (присваивать ей значения, выводить)
    
    printf("%d", *ptr);
    
    free(ptr);                             // САМОЕ ВАЖНОЕ СДЕЛАТЬ ОЧИСТКУ ПАМЯТИ
    
    return 0;
}
```

## Value & Reference Types
Все типы данных делятся на две группы.
* *Value type*
* *Reference type*

*Value type (тип значения)* - Хранит собственное значение в памяти расположенной на stack.

```objc
#include <stdio.h>

void foo() {
     int a = 123;         // Value type variable
     printf("%d", a);
}
```
*Reference type (тип ссылка)* - Использует ссылку в качестве инструмента доступа к значению объекта. При этом эта ссылка не хранит значение самого объекта, а только ссылается на него.

*object*
| 0x1 | 
| --- | 
| value = 3 | 

* RT variable 1 (переменная является ссылкой)
* RT variable 2 (переменная является ссылкой)
* RT variable 3 (переменная является ссылкой)
* ...

Все объекты будут знать об изменениях

## Pointers
Указатель - это переменная значением который является адресс другой переменной.
При этом указатель это переменная *Value type*.
Reference type основаны на указателях.

Два основных оператора для работы с указателями:
* "&" - опертор взятия адреса 
* "*" -  оператор разыменования

```objc
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int *a;           // переменная указатель
    int b = 123;
    
    a = &b;           // берем адрес другой переменной (b) с помощью оператора & 
    
    printf("%d\n", b);   // 123
    printf("%d\n", *a);  // 123
    
    *a = 432;            // с помощью оператора разыменования изменяем значения переменной 
    
    // same as
    // b = 432
    
    printf("%d\n", b);  // 423
    printf("%d\n", *a); // 423
    
    return 0;
}

```
## Object-Oriented Programming

Используется понятие:
* Класс - это шаблон для создания объектов, он описывает набор методов и свойств которые будут доступны для работы с объектом.
* Объект - конкретный экземпляр класса. 

### Принципы

* Абстракция 

Абстракция - выделение наиболее значимых характеристик объекта или системы. Значимость характеристики определяется контекстом в котором будет использоваться объект.

* Наследование 

Наследование - это механизм базирования класса на другом классе. Между классами создаются отношения *родитель-потомок*. Класс потом принимает интерфейс класса родителя и может его расширить путем добавления новых методов и свойств.

* Полиморфизм 

Полиморфизм - это работа с одним интерфейсом, который может быть реализован различными типами. Например: использования интерфейса класса родителя. Предоставления различных его реализаций через классы потомки. 

* Инкапсуляция 

Инкапсуляция - это сокрытие деталей класса в виде его приватных методов и свойств. И предоставления публичных методов для работы с этим классом.

* Отправка сообщений 

Отправка сообщений - предузумевает, что объект имеет возможность предоставить реализацию метода при его вызове. И именно он отвечает за это, а не код который вызывал этот метод.

* ...

